<?php

use Nether\Atlantis;
use Nether\Common;
use Nether\Console;
use Nether\Storage;
use Nether\User;

(function(){
	require(sprintf('%s/autoload.php', dirname(__DIR__, 3)));
	return;
})();

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

#[Console\Meta\Application('DevTool', '5.0.0-dev')]
#[Common\Meta\Info('Handles configuration and setup for project development.')]
class DevTool
extends Atlantis\TerminalApp {

	////////////////////////////////////////////////////////////////
	// OVERRIDES Console\Client ////////////////////////////////////

	#[Common\Meta\Date('2023-11-14')]
	protected function
	ApplyDefaultSort():
	void {

		$this->Commands = (
			Common\Datastore::FromArray(array_flip([
				'run',
				'project-init', 'project-setup',
				'web-config', 'web-setup', 'web-reload'
			]))
			->RemapKeyValue(fn(string $K)=> $this->Commands->Get($K))
			->EachKeyValue(fn(string $K)=> $this->Commands->Remove($K))
			->MergeRight($this->Commands)
		);

		return;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Common\Meta\Date('2023-11-08')]
	#[Console\Meta\Command('run')]
	#[Console\Meta\Info('Run one of the pre-defined command sequences from the project config.')]
	#[Console\Meta\Arg('cmdname', 'The command list to run.')]
	#[Console\Meta\Error(1, 'no command specified')]
	#[Console\Meta\Error(2, 'command not found (%s)')]
	#[Console\Meta\Toggle('--dry', 'Only make believe.')]
	#[Console\Meta\Toggle('--cmd', 'Show the command that it executes.')]
	#[Console\Meta\Toggle('--hush', 'Do not show the output of commands unless error.')]
	public function
	HandleRunCommand():
	int {

		$Confs = Atlantis\Struct\ProjectJSON::FromApp($this->App);
		$InputCmd = $this->GetInput(1) ?? NULL;

		// this was the most hillarious way to quickly pivot to the app
		// returning a stack. but i want to build this kind of merging
		// into the project json itself later anyway.

		$Conf = new Atlantis\Struct\ProjectJSON([
			'Dev' => ([
				'Run' => ([
					'Commands' => (
						Common\Struct\CommandList::FromStackMerged([], ...(
							$Confs->Map(
								fn(Atlantis\Struct\ProjectJSON $D)
								=> $D->Dev->Run->Commands
							)
							->GetData()
						))
					)
				])
			])
		]);

		////////

		$OptShowCmd = $this->GetOption('cmd') ?? FALSE;
		$OptHushOut = $this->GetOption('hush') ?? FALSE;
		$OptDry = $this->GetOption('dry') ?? FALSE;

		$Command = NULL;
		$Steps = NULL;

		$Tokens = Common\Datastore::FromArray([
			'ProjectRoot' => $this->App->GetProjectRoot()
		]);

		$PrintHelpRegardingKnownCommands = function(Atlantis\Struct\ProjectJSON $C) {

			$this->PrintLn($this->FormatHeaderPoint(
				'Known Commands:',
				static::FmtAccent
			), 2);

			$this->PrintLn(join(', ', $C->Dev->Run->Commands->Keys()), 2);

			return;
		};

		$PrintHelpRegardingJSON = function(string $Name=NULL) {

			$this->PrintLn($this->FormatHeaderPoint(
				'Project JSON:',
				static::FmtAccent
			), 2);

			$this->PrintLn(join(
				$this->Format(' > ', static::FmtMuted),
				[ 'atlantis.json', 'Dev', 'Run', 'Commands' ]
			), 2);

			$Output = Common\Text::ReadableJSON([
				'Dev' => [ 'Run' => [ 'Commands' => (
					Common\Struct\CommandList::FromArray([
						'{%CmdName%}' => [ 'Steps'=> [
							'{%CmdLabel%}'=> '{%CmdLine%}'
						] ]
					])
					->ToArray()
				) ] ]
			]);

			$Output = Common\Datastore::FromArray([
				[ 'CmdName', ($Name ?? 'your-command-name') ]
			])
			->Accumulate($Output, fn($C, $I)
				=> str_replace(
					Common\Text::TemplateMakeToken($I[0]), $I[1], $C
				)
			);

			$Output = preg_replace_callback(
				'/([\{\}]$|[\:] )/ms',
				(fn(array $M)=> $this->Format($M[0], static::FmtMuted)),
				$Output
			);

			$this->PrintLn($Output, 2);

			return;
		};

		////////

		if(!$InputCmd) {
			$PrintHelpRegardingKnownCommands($Conf);
			$this->Quit(1);
		}

		if(!$Conf->Dev->Run->Commands->HasKey($InputCmd)) {
			$PrintHelpRegardingJSON($InputCmd);
			$this->Quit(2, $InputCmd);
		}

		////////

		$Command = $Conf->Dev->Run->Commands->Get($InputCmd);
		$Steps = $Command->Steps->Map(fn($D)=> $D);

		// items with their label prefixed with a hash are disabled
		// such that they should be skipped completely by pulling them out
		// of the todo list.

		$Steps->Filter(
			fn(string $Cmd, string $Lbl)
			=> !str_starts_with($Lbl, '#')
		);

		////////

		$this->PrintLn($this->FormatHeaderBlock(sprintf(
			'%s Run: %s',
			$this->AppInfo->Name,
			$InputCmd
		)), 2);

		if(!$Steps->Count()) {
			$this->PrintLn('Nothing to do.', 2);
			return 0;
		}

		////////

		$Steps->Each(
			function(string $Command, string $Label)
			use($OptShowCmd, $OptHushOut, $OptDry, $Tokens) {

				$Cmd = match(TRUE) {

					// prefixing the command with # becomes a soft
					// skip where it will mention it skipped it.

					str_starts_with($Command, '#')
					=> NULL,

					// prefixing the command with an at-sign makes it
					// a library alias.

					str_starts_with($Command, '@')
					=> Console\CommandLibrary::FromNote(
						$Command, $Tokens
					),

					// anything else is just treated as a command
					// line string.

					default
					=> Console\CommandLibrary::FromString(
						$Command, $Tokens
					)

				};

				$CmdOutStyle = static::FmtMuted;
				$CmdOutLabel = 'STDOUT';

				$CmdStatusStyle = static::FmtOK;
				$CmdStatusLabel = 'OK';

				////////

				if($Cmd === NULL) {
					$this->PrintLn($this->FormatHeaderLine(
						"Skipped: {$Label}",
						Console\Theme::Muted
					), 2);

					return;
				}

				////////

				$this->PrintLn($this->FormatHeaderLine(
					"Step: {$Label}",
					static::FmtAccent
				), 2);

				if($OptShowCmd) {
					$this->PrintLn($this->Format(
						'Command:',
						static::FmtAccent
					));
					$this->PrintLn($Cmd, 2);
				}

				if($OptDry) {
					$this->PrintLn($this->FormatHeaderPoint(
						'DRY RUN',
						Console\Theme::Muted
					), 2);

					return;
				}

				////////

				$Result = $this->ExecuteCommandLine($Cmd, TRUE);

				if($Result->HasError()) {
					$CmdOutStyle = static::FmtError;
					$CmdStatusStyle = static::FmtError;
					$CmdStatusLabel = sprintf('ERROR: %d', $Result->Error);
					$OptHushOut = FALSE;
				}

				$this->PrintLn($this->FormatHeaderPoint(
					$CmdStatusLabel,
					$CmdStatusStyle
				), 2);

				////////

				if(!$OptHushOut) {
					$this->PrintLn($this->FormatHeaderPoint(
						$CmdOutLabel,
						$CmdOutStyle
					), 2);

					$this->PrintLn($this->Format(
						$Result->GetOutputString(),
						$CmdOutStyle
					), 2);
				}

				return;
			}
		);

		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Console\Meta\Command('project-init')]
	#[Console\Meta\Info('Begin setting up the project from scratch.')]
	public function
	HandleInit():
	int {

		// git clone git@github.com:netherphp/project .
		// composer require netherphp/atlantis dev-master

		// dev.atl init
		// ssl.atl setup

		// things best only done once.

		$this->HandleProjectDist();
		$this->HandleProjectGitIgnore();

		// things that are safer to repeat technically.

		$this->HandleSetup();

		return 0;
	}

	#[Console\Meta\Command('project-setup')]
	#[Console\Meta\Info('Reconfigure anything that can be reconfigured easily.')]
	#[Console\Meta\Toggle('--fix', 'Try to forcefully fix things considered errors.')]
	public function
	HandleSetup():
	int {

		$this->HandleProjectPaths();

		return 0;
	}

	#[Common\Meta\Date('2023-11-11')]
	#[Console\Meta\Command('project-paths', TRUE)]
	#[Console\Meta\Toggle('--fix', 'Try to forcefully fix things considered errors.')]
	public function
	HandleProjectPaths():
	int {

		$OptFix = $this->GetOption('fix') ?? FALSE;

		////////

		$this->PrintLn($this->FormatHeaderLine(
			sprintf('%s: Project Path Setup', $this->AppInfo->Name)
		), 2);

		////////

		Atlantis\Struct\ProjectJSON::FromApp($this->App)
		->Filter(
			fn(Atlantis\Struct\ProjectJSON $Project)
			=> !!$Project->Dirs->Count() && !!$Project->Symlinks->Count()
		)
		->Each(
			function(Atlantis\Struct\ProjectJSON $Project, string $Key)
			use($OptFix) {
				$this->PrintLn($this->FormatHeaderPoint(
					"{$Key} ({$Project->Filename})",
					Console\Theme::Accent
				), 2);
				$this->SetupProjectDirs($Project, $OptFix);
				$this->SetupProjectLinks($Project, $OptFix);
				return;
			}
		);

		////////

		return 0;
	}

	#[Common\Meta\Date('2023-11-11')]
	#[Console\Meta\Command('project-dist', TRUE)]
	public function
	HandleProjectDist():
	int {

		$AppRoot = $this->App->FromProjectRoot();
		$DistRoot = $this->App->FromProjectRoot(Common\Filesystem\Util::Pathify(
			'vendor', 'netherphp', 'atlantis'
		));

		////////

		$this->PrintLn($this->FormatHeaderPoint(
			'Setup Atlantis Structure...',
			Console\Theme::Accent
		), 2);

		Common\Datastore::FromArray([
			Common\Filesystem\Util::Pathify($AppRoot, 'conf', 'env', 'dev'),
			Common\Filesystem\Util::Pathify($AppRoot, 'core', 'Local'),
			Common\Filesystem\Util::Pathify($AppRoot, 'data'),
			Common\Filesystem\Util::Pathify($AppRoot, 'logs'),
			Common\Filesystem\Util::Pathify($AppRoot, 'temp'),
			Common\Filesystem\Util::Pathify($AppRoot, 'www')
		])
		->Each(function(string $Dir) {
			$this->PrintLn(sprintf('[%s] %s',
				$this->Format('DIR', static::FmtAccent),
				$Dir
			));

			Common\Filesystem\Util::MkDir($Dir);
			return;
		});

		$this->PrintLn();

		////////

		$Todo = Common\Datastore::FromArray([
			Common\Filesystem\Util::Pathify('app', 'conf')
			=> 'conf',

			Common\Filesystem\Util::Pathify('app', 'routes')
			=> 'routes',

			Common\Filesystem\Util::Pathify('app', 'atlantis.json')
			=> Common\Filesystem\Util::Pathify('atlantis.json'),

			Common\Filesystem\Util::Pathify('app', 'composer.json')
			=> Common\Filesystem\Util::Pathify('composer.json'),

			Common\Filesystem\Util::Pathify('app', 'www', 'index.php')
			=> Common\Filesystem\Util::Pathify('www', 'index.php')
		]);

		$Todo->Each(function(string $Dst, string $Src) use($DistRoot, $AppRoot) {

			$Copy = Atlantis\Util::CopyWithConfirm(
				Common\Filesystem\Util::Pathify($DistRoot, $Src),
				Common\Filesystem\Util::Pathify($AppRoot, $Dst)
			);

			$Cur = NULL;

			foreach($Copy as $Cur) {
				if(is_string($Cur)) {
					$Copy->Send(!$this->PromptTrue(
						$this->Format("Overwrite {$Cur}?", Console\Theme::Accent),
						'[N/y]'
					));

					continue;
				}
			}

			return;
		});

		return 0;
	}

	#[Common\Meta\Date('2023-11-11')]
	#[Console\Meta\Command('project-gitignore', TRUE)]
	#[Console\Meta\Info('Add things this framework knows you need to .gitignore')]
	#[Console\Meta\Error(1, 'file write error: %s')]
	public function
	HandleProjectGitIgnore():
	int {

		$this->PrintLn($this->FormatHeaderLine(
			sprintf('%s: Git Ignore Config', $this->AppInfo->Name)
		), 2);

		$Things = Common\Datastore::FromArray([
			'Local Dev Things' => Common\Datastore::FromArray([
				'PHPUnit'                     => '/.phpunit.cache',
				'Composer'                    => '/vendor',
				'Local Environment Lock File' => '/env.lock',
				'Local Backup Dir'            => '/backups',
				'Local Log Dir'               => '/logs',
				'Local Temporary Thrash Dir'  => '/temp'
			]),

			'Local Web Things' => Common\Datastore::FromArray([
				'AcmePHP Server Validation'  => '/www/.well-known',
				'Atlantis App Scripts'       => '/www/share/atlantis',
				'Atlantis NUI Scripts'       => '/www/share/nui',
				'Atlantis Default Theme'     => '/www/themes/default',
				'Atlantis Coming Soon Theme' => '/www/themes/soon'
			]),

			'Framework Managed Things' => Common\Datastore::FromArray([
				'Nether Blog Uploads'              => '/data/blog',
				'Nether Blog Uploads (Symlink)'    => '/www/data/blog',
				'Atlantis QR Codes'                => '/data/qr',
				'Atlantis QR Codes (Symlink)'      => '/www/data/qr',
				'Atlantis File Uploads'            => '/data/upl',
				'Atlantis File Uploads (Symlink)'  => '/www/data/upl',
				'Atlantis VideoTP Cache'           => '/data/vid',
				'Atlantis VideoTP Cache (Symlink)' => '/www/data/vid'
			])
		]);

		$File = $this->App->FromProjectRoot('.gitignore');
		$Ignore = new Atlantis\Util\GitIgnoreTool($File);

		$Things->Each(function(Common\Datastore $Group, string $Key) use($Ignore) {
			$this->PrintLn($this->FormatHeaderPoint($Key, Console\Theme::Accent), 2);
			$this->PrintLn($this->FormatBulletList($Group), 2);
			$Ignore->Append($Group->Values(TRUE));
			return;
		});

		try { $Ignore->Write(); }
		catch(Exception $Err) {
			$this->PrintLn($this->FormatHeaderPoint(
				"ERROR: {$Err->GetMessage()}",
				Console\Theme::Error
			), 2);

			$this->Quit(1, $Err->GetMessage());
		}

		$this->PrintLn($this->FormatHeaderPoint('OK', Console\Theme::OK), 2);

		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Console\Meta\Command('web-config')]
	#[Console\Meta\Info('Prepare web server configuration files.')]
	#[Console\Meta\Toggle('--dry', 'Show the resulting JSON instead of updating the file.')]
	#[Console\Meta\Error(1, 'No atlantis.json selected.')]
	#[Console\Meta\Error(2, 'Write error on project json: %s')]
	#[Console\Meta\Error(3, 'Write error on server config: %s')]
	public function
	HandleWebConfig():
	int {

		$OptDry = $this->GetOption('dry') ?? FALSE;
		$Project = NULL;
		$Err = NULL;

		$this->PrintLn($this->FormatHeaderLine(
			sprintf('%s: Web Server Config', $this->AppInfo->Name)
		), 2);

		////////

		$Project = $this->QuerySelectProjectConfig(
			fn(Atlantis\Struct\ProjectJSON $V, string $K)
			=> $K === 'Env'
		);

		if(!$Project)
		$this->Quit(1);

		$Project->Web = $this->QueryWebServerConfig($Project);

		////////

		if($OptDry) {
			$this->PrintLn($this->FormatHeaderPoint('Dry Run', Console\Theme::Muted), 2);
			$this->PrintLn($Project->Web->ToJSON(), 2);
			return 0;
		}

		////////

		try { $this->WriteProjectConfig($Project); }
		catch(Exception $Err) {
			$this->PrintLn($this->FormatHeaderPoint(
				"ERROR: {$Err->GetMessage()}",
				Console\Theme::Error
			), 2);

			$this->Quit(2, $Err->GetMessage());
		}

		$this->PrintLn($this->FormatHeaderPoint('OK', Console\Theme::OK), 2);

		////////

		try { $this->WriteWebServerConfig($Project); }
		catch(Exception $Err) {
			$this->PrintLn($this->FormatHeaderPoint(
				"ERROR: {$Err->GetMessage()}",
				Console\Theme::Error
			), 2);

			$this->Quit(3, $Err->GetMessage());
		}

		$this->PrintLn($this->FormatHeaderPoint('OK', Console\Theme::OK), 2);

		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Console\Meta\Command('web-setup')]
	#[Console\Meta\Info('Push and confirm web server configuration setup.')]
	#[Console\Meta\Error(1, 'No atlantis.json selected.')]
	#[Console\Meta\Error(2, 'No Web configuration or incomplete.')]
	#[Console\Meta\Error(3, 'Invalid/Unsupported web server type.')]
	public function
	HandleWebSetup():
	int {

		$this->PrintLn($this->FormatHeaderLine(
			sprintf('%s: Web Server Setup', $this->AppInfo->Name)
		), 2);

		$Project = $this->QuerySelectProjectConfig(
			fn(Atlantis\Struct\ProjectJSON $V, string $K)
			=> $K === 'Env'
		);

		if(!$Project)
		$this->Quit(1);

		if(!$Project->Web->IsConfigured())
		$this->Quit(2);

		if($Project->Web->Sudo && $this->Sudo())
		$this->Quit(0);

		////////

		try { $this->SetupWebServer($Project); }
		catch(Exception $Err) {
			$this->Quit(3, $Err->GetMessage());
		}

		try { $this->RehashWebServer($Project); }
		catch(Exception $Err) {
			$this->Quit(3, $Err->GetMessage());
		}

		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Console\Meta\Command('web-reload')]
	#[Console\Meta\Info('Kick web server to reload configuration.')]
	#[Console\Meta\Error(1, 'No Web config in atlantis.json')]
	#[Console\Meta\Error(2, 'No valid server Type')]
	#[Console\Meta\Error(3, 'server error: %s')]
	public function
	HandleWebReload():
	int {

		$this->PrintLn($this->FormatHeaderLine(
			sprintf('%s: Web Server Reload', $this->AppInfo->Name)
		), 2);

		$Project = $this->QuerySelectProjectConfig(
			fn(Atlantis\Struct\ProjectJSON $V, string $K)
			=> $K === 'Env'
		);

		if(!$Project)
		$this->Quit(1);

		if(!$Project->Web->IsConfigured())
		$this->Quit(2);

		if($Project->Web->Sudo && $this->Sudo())
		$this->Quit(0);

		////////

		try { $this->RehashWebServer($Project); }
		catch(Exception $Err) {
			$this->Quit(3, $Err->GetMessage());
		}

		////////

		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Console\Meta\Command('jsondbg', TRUE)]
	#[Console\Meta\Info('Debug tool for atlantis.json')]
	#[Console\Meta\Error(1, 'no project json selected')]
	#[Console\Meta\Toggle('--struct', 'Print the parsed structure.')]
	#[Console\Meta\Toggle('--json', 'Print the JSON structure.')]
	#[Console\Meta\Toggle('--touch', 'Touch the selected JSON file.')]
	#[Console\Meta\Toggle('--rewrite', 'Rewrite the selected JSON file.')]
	#[Common\Meta\Date('2023-11-10')]
	public function
	HandleDebugAtlantisJSON():
	int {

		$Now = Common\Date::Unixtime();
		$OptStruct = $this->GetOption('struct') ?? FALSE;
		$OptJSON = $this->GetOption('json') ?? FALSE;
		$OptTouch = $this->GetOption('touch') ?? FALSE;
		$OptRewrite = $this->GetOption('rewrite') ?? FALSE;

		$Project = NULL;
		$Listable = NULL;

		////////

		$this->PrintLn($this->FormatHeaderLine(
			sprintf('%s: Project JSON Debugger', $this->AppInfo->Name)
		), 2);

		$Project = $this->QuerySelectProjectConfig();

		if(!$Project)
		$this->Quit(1);

		$this->PrintLn($this->FormatHeading('Selected:', static::FmtAccent));
		$this->PrintLn($Project->Filename, 2);

		////////

		if($OptStruct) {
			$this->PrintLn($this->FormatHeaderLine('ProjectJSON Structures'), 2);

			$Listable = Common\Datastore::FromArray(Common\Meta\PropertyListable::FromClass($Project::class));
			$Listable->Each(function(Common\Prototype\PropertyInfo $P) use($Project) {
				$this->PrintLn($this->FormatHeaderPoint("ProjectJSON.{$P->Name}", static::FmtAccent), 2);
				Common\Dump::Var($Project->{$P->Name});
				$this->PrintLn();
				return;
			});
		}

		if($OptJSON) {
			$this->PrintLn($this->FormatHeaderLine('ProjectJSON as JSON'), 2);
			$this->PrintLn($Project->ToJSON());
			$this->PrintLn();
		}

		if($OptTouch) {
			$this->PrintLn($this->FormatHeaderLine('Touching ProjectJSON'), 2);

			(function(Atlantis\Struct\ProjectJSON $P, int $T) {
				$Touched = touch($P->Filename, $T, $T);

				if($Touched)
				$this->PrintLn($this->FormatHeaderPoint(
					'OK',
					static::FmtOK
				), 2);

				else
				$this->PrintLn($this->FormatHeaderPoint(
					'Failed to touch file.',
					static::FmtError
				), 2);

				return;
			})($Project, $Now);
		}

		if($OptRewrite) {
			$this->PrintLn($this->FormatHeaderLine('Rewriting ProjectJSON'), 2);

			(function(Atlantis\Struct\ProjectJSON $P) {

				$Err = NULL;

				try { $P->Write(); }
				catch(Exception $Err) {
					$this->PrintLn($this->FormatHeaderPoint("Error: {$Err->GetMessage()}", static::FmtError), 2);
				}

				if($Err === NULL)
				$this->PrintLn($this->FormatHeaderPoint('OK', static::FmtOK), 2);

				return;
			})($Project);

		}

		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Console\Meta\Command('loc', TRUE)]
	public function
	HandleCountLinesOfCode():
	int {

		$this->PrintAppHeader('Count Lines of Code');

		$InputPaths = (
			($this->Args->Inputs->Copy())
			->Map(fn(string $P)=> realpath($P))
			->Filter(fn(?string $P)=> !!$P)
		);

		$OptNether = $this->GetOption('nether') ?? FALSE;
		$OptExt = [ 'php' ];

		////////

		$this->PrintLn($this->FormatHeading('Paths:'));

		if($OptNether)
		$InputPaths->MergeRight($this->FetchNetherProjectSourceDirs());

		$InputPaths->Each(
			fn(string $D)=>
			$this->PrintLn("{$this->Theme->GetCharBullet()} {$D}")
		);

		$this->PrintLn();

		////////

		$this->PrintStatusMuted('Seeking Files...');

		$Files = (
			($InputPaths)
			->Accumulate((new Common\Datastore), (
				fn(Common\Datastore $C, string $P)
				=> $C->MergeRight(Common\Filesystem\Indexer::ArrayFromPath(
					$P, TRUE, TRUE
				))
			))
			->Filter(
				fn(SplFileInfo $F)
				=> in_array(strtolower($F->GetExtension()), $OptExt)
			)
		);

		////////

		$this->PrintStatusMuted('Counting Lines...');

		$Count = $Files->Accumulate(0, (
			fn(int $C, SplFileInfo $F)
			=> $C + Common\Filesystem\Util::LineCount($F->GetRealPath())
		));

		$this->PrintLn(sprintf(
			'%s lines across %s files.',
			number_format($Count),
			number_format($Files->Count())
		), 2);

		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Console\Meta\Command('ctimeline', TRUE)]
	public function
	HandleClassTimeline():
	int {

		// open a class look at the methods and properties and
		// print out a list sorted by when they were added.

		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	public function
	FetchNetherProjectSourceDirs():
	Common\Datastore {

		$NetherRoot = Common\Filesystem\Util::Pathify(
			'vendor', 'netherphp'
		);

		$Output = (
			Common\Filesystem\Indexer::DatastoreFromPath(
				$this->App->FromProjectRoot($NetherRoot)
			)
			->Map(
				fn(string $D)
				=> realpath(Common\Filesystem\Util::Pathify($D, 'src'))
			)
			->Filter(
				fn(string $D)=>
				!!$D
			)
			->Sort()
		);

		return $Output;
	}

	#[Common\Meta\Date('2023-11-11')]
	public function
	RehashWebServer(Atlantis\Struct\ProjectJSON $Project):
	void {

		match(TRUE) {
			$Project->Web->IsType(($Project->Web)::TypeApacheCtl)
			=> $this->RehashWebServerApache24($Project),

			default
			=> throw new Exception('Unknown Web Server Type')
		};

		return;
	}

	#[Common\Meta\Date('2023-11-11')]
	public function
	RehashWebServerApache24(Atlantis\Struct\ProjectJSON $Project):
	void {

		$Result = $this->ExecuteCommandLine('apachectl graceful', TRUE);

		if($Result->HasError()) {
			$this->PrintLn($this->FormatHeaderPoint('ERROR', Console\Theme::Error), 2);
			$this->PrintLn($this->Format(
				$Result->GetOutputString(),
				Console\Theme::Error
			));

			return;
		}

		$this->PrintLn($this->FormatHeaderPoint(
			'OK - Web Server Rehashed',
			Console\Theme::OK
		), 2);

		return;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Common\Meta\Date('2023-11-11')]
	public function
	SetupWebServer(Atlantis\Struct\ProjectJSON $Project):
	static {

		return match(TRUE) {
			$Project->Web->IsType(($Project->Web)::TypeApacheCtl)
			=> $this->SetupWebServerApache24($Project),

			default
			=> throw new Exception('Unknown Web Server Type')
		};
	}

	#[Common\Meta\Date('2023-11-11')]
	public function
	SetupWebServerApache24(Atlantis\Struct\ProjectJSON $Project):
	static {

		$ApacheBaseDir = '/etc/apache2/sites-enabled';
		$LocalConfigFile = 'apache24.conf';

		$SourceFile = $this->App->FromConfEnv($LocalConfigFile);
		$EnvType = $this->App->GetProjectEnvType();
		$EnvName = $this->App->Config[Atlantis\Key::ConfProjectID];
		$EnvNum = match($EnvType) {
			'dev'   => 100,
			'demo'  => 800,
			'prod'  => 900,
			default => 999
		};

		$Filename = sprintf('%s-%s-%s.conf', $EnvNum, $EnvName, $EnvType);
		$LinkFile = Common\Filesystem\Util::Pathify($ApacheBaseDir, $Filename);

		////////

		$this->PrintLn($this->FormatBulletList([
			'Source' => $SourceFile,
			'Link'   => $LinkFile
		]), 2);

		if(file_exists($LinkFile)) {
			if(is_link($LinkFile)) {
				if(Common\Filesystem\Util::IsLinkTo($LinkFile, $SourceFile))
				$this->PrintLn($this->FormatHeaderPoint(
					'OK - Symlink exists and is correct.',
					Console\Theme::OK
				), 2);

				else
				$this->PrintLn($this->FormatHeaderPoint(
					sprintf('ERROR - Symlink exists but points to %s', readlink($LinkFile)),
					Console\Theme::Error
				), 2);
			}

			else {
				$this->PrintLn($this->FormatHeaderPoint(
					"ERROR - File exists where we want to put the symlink: {$LinkFile}",
					Console\Theme::Error
				), 2);
			}

			return $this;
		}

		////////

		symlink(realpath($SourceFile), $LinkFile);

		if(file_exists($LinkFile))
		$this->PrintLn($this->FormatHeaderPoint('OK', Console\Theme::OK), 2);
		else
		$this->PrintLn($this->FormatHeaderPoint('ERROR', Console\Theme::Error), 2);

		return $this;
	}

	#[Common\Meta\Date('2023-11-11')]
	public function
	SetupProjectDirs(Atlantis\Struct\ProjectJSON $Project, bool $OptFix=FALSE):
	static {

		$Report = new Common\Datastore;

		$Printer = function(string $V, string $K) {
			$Label = 'DIR';

			if($V === 'OK' || $V === 'NEW' || $V === 'FIXED') {
				$this->PrintLn(sprintf(
					'[%s] %s (%s)',
					$this->Format($Label, Console\Theme::OK),
					$K, $V
				));

				return;
			}

			$this->PrintLn(sprintf(
				'[%s] %s (%s)',
				$this->Format($Label, Console\Theme::Error),
				$K, $V
			));

			return;
		};

		$Tester = function(Common\Filesystem\Directory $Dir) use($Report) {

			if(is_dir($Dir->Path)) {
				$Report[$Dir->Path] = 'OK';
				return;
			}

			if(is_file($Dir->Path)) {
				$Report[$Dir->Path] = 'ERROR: Exists as File';
				return;
			}

			Common\Filesystem\Util::MkDir($Dir->Path);

			if(!is_dir($Dir->Path)) {
				$Report[$Dir->Path] = "ERROR: Permission Denied";
				return;
			}

			$Report[$Dir->Path] = 'NEW';

			return;
		};

		$Fixer = function(Common\Filesystem\Directory $Dir) use($Report) {

			if(is_file($Dir->Path)) {
				unlink($Dir->Path);
				Common\Filesystem\Util::MkDir($Dir->Path);

				if(is_dir($Dir->Path)) {
					$Report[$Dir->Path] = 'FIXED';
				}

				return;
			}

			return;
		};

		////////

		$Project->Dirs->Each($Tester);
		$Report->Each($Printer);
		$this->PrintLn();

		////////

		$Retry = $Project->Dirs->Distill(
			fn(Common\Filesystem\Directory $D)
			=> str_starts_with($Report[$D->Path], 'ERROR:')
		);

		if($Retry->Count() === 0)
		$this->PrintLn($this->FormatHeaderPoint(
			'OK', Console\Theme::OK
		), 2);

		else
		$this->PrintLn($this->FormatHeaderPoint(
			"ERROR: Needs fixed: {$Retry->Count()}", Console\Theme::Error
		), 2);

		if($Retry->Count() && $OptFix) {
			$Report->Clear();
			$Retry->Each($Fixer);
			$Report->Each($Printer);
			$this->PrintLn();
		}

		////////

		return $this;
	}

	#[Common\Meta\Date('2023-11-11')]
	public function
	SetupProjectLinks(Atlantis\Struct\ProjectJSON $Project, bool $OptFix=FALSE):
	static {

		$Report = new Common\Datastore;

		$Printer = function(string $V, string $K) {
			$Label = 'SYM';

			if($V === 'OK' || $V === 'NEW' || $V === 'FIXED') {
				$this->PrintLn(sprintf(
					'[%s] %s (%s)',
					$this->Format($Label, Console\Theme::OK),
					$K, $V
				));

				return;
			}

			$this->PrintLn(sprintf(
				'[%s] %s (%s)',
				$this->Format($Label, Console\Theme::Error),
				$K, $V
			));

			return;
		};

		$Tester = function(Common\Filesystem\Symlink $Dir) use($Report) {

			if(is_file($Dir->Path)) {
				if(is_link($Dir->Path)) {
					if(Common\Filesystem\Util::IsLinkTo($Dir->Path, realpath($Dir->Source))) {
						$Report[$Dir->Path] = 'OK';
						return;
					}

					$Report[$Dir->Path] = 'Error: Exists as a symlink pointing to wrong thing.';
					return;
				}

				$Report[$Dir->Path] = 'ERROR: Exists as File';
				return;
			}

			if(is_dir($Dir->Path)) {
				if(is_link($Dir->Path)) {
					if(Common\Filesystem\Util::IsLinkTo($Dir->Path, realpath($Dir->Source))) {
						$Report[$Dir->Path] = 'OK';
						return;
					}
				}

				$Report[$Dir->Path] = 'ERROR: Exists as Directory';
				return;
			}

			if(Common\Filesystem\Util::IsLinkTo($Dir->Path, realpath($Dir->Source))) {
				$Report[$Dir->Path] = 'OK';
				return;
			}

			symlink(realpath($Dir->Source), $Dir->Path);

			if(!is_link($Dir->Path)) {
				$Report[$Dir->Path] = "ERROR: Permission Denied";
				return;
			}

			$Report[$Dir->Path] = 'NEW';
			return;
		};

		$Fixer = function(Common\Filesystem\Symlink $Dir) use($Report) {

			if(is_link($Dir->Path) || is_file($Dir->Path)) {
				unlink($Dir->Path);
				symlink(realpath($Dir->Source), $Dir->Path);

				if(Common\Filesystem\Util::IsLinkTo($Dir->Path, realpath($Dir->Source))) {
					$Report[$Dir->Path] = 'FIXED';
					return;
				}

				$Report[$Dir->Path] = 'ERROR: Fixing failed.';
				return;
			}

			if(is_dir($Dir->Path)) {
				Common\Filesystem\Util::RmDir($Dir->Path);
				symlink(realpath($Dir->Source), $Dir->Path);

				if(Common\Filesystem\Util::IsLinkTo($Dir->Path, realpath($Dir->Source))) {
					$Report[$Dir->Path] = 'FIXED';
					return;
				}

				$Report[$Dir->Path] = 'ERROR: Fixing failed.';
				return;
			}

			$Report[$Dir->Path] = 'ERROR: No fix available for whatever is wrong.';
			return;
		};

		////////

		$Project->Symlinks->Each($Tester);
		$Report->Each($Printer);
		$this->PrintLn();

		////////

		$Retry = $Project->Symlinks->Distill(
			fn(Common\Filesystem\Symlink $D)=>
			str_starts_with($Report[$D->Path], 'ERROR:')
		);

		if($Retry->Count() === 0)
		$this->PrintLn($this->FormatHeaderPoint(
			'OK', Console\Theme::OK
		), 2);

		else
		$this->PrintLn($this->FormatHeaderPoint(
			"ERROR: Needs fixed: {$Retry->Count()}", Console\Theme::Error
		), 2);

		if($Retry->Count() && $OptFix) {
			$Report->Clear();
			$Retry->Each($Fixer);
			$Report->Each($Printer);
			$this->PrintLn();
		}

		////////

		return $this;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	use
	Atlantis\Packages\DevTool\QuerySelectProjectConfig,
	Atlantis\Packages\DevTool\QueryDomainLineList;

	#[Common\Meta\Date('2023-11-11')]
	#[Common\Meta\Info('Engage an interaction mode to extract web server configuration from the user.')]
	public function
	QueryWebServerConfig(Atlantis\Struct\ProjectJSON $Project):
	Atlantis\Struct\ProjectJSON\WebJSON {

		$Server = (
			isset($Project->Web)
			? $Project->Web
			: new Atlantis\Struct\ProjectJSON\WebJSON
		);

		////////

		$this->PrintLn($this->FormatHeaderLine('Web Server Types', static::FmtAccent), 2);
		$this->PrintLn($this->FormatBulletList(Atlantis\Struct\ProjectJSON\WebJSON::Types), 2);

		$Server->Type = $this->PromptForValue(
			Required: TRUE,
			Name: 'Select Type',
			Type: 'Number',
			Default: (
				$Server->Type
				? ($Server::Type($Server->Type) + 1)
				: NULL
			),
			Filter: function(?string $In) {
				if(in_array($In, Atlantis\Struct\ProjectJSON\WebJSON::Types))
				return $In;

				if(!is_numeric($In))
				return NULL;

				return Atlantis\Struct\ProjectJSON\WebJSON::Type((int)$In - 1);
			}
		);

		$this->PrintLn($this->FormatHeaderLine(
			"Selected: {$Server->Type}", static::FmtMuted
		), 2);

		////////

		$this->PrintLn($this->FormatHeaderLine('HTTPS/SSL', static::FmtAccent), 2);
		$this->PrintLn($this->FormatWrap(''
			. 'First Time setup or Local Dev it is useful to say no here to get it running on basic HTTP. '
			. 'Once the cert is acquired this tool may be ran again to update the required configuration files.'
		), 2);

		$Server->HTTPS = $this->PromptForValue(
			Required: TRUE,
			Name: 'Use HTTPS?',
			Type: 'y/n',
			Default: ($Server->HTTPS ? 'y' : 'n'),
			Filter: Common\Filters\Numbers::BoolType(...)
		);

		$this->PrintLn($this->FormatHeaderLine(
			sprintf('Selected: %s', ($Server->HTTPS ? 'Yes' : 'No')),
			static::FmtMuted
		), 2);

		////////

		$this->PrintLn($this->FormatHeaderLine('Domains', static::FmtAccent), 2);
		$this->PrintLn($this->FormatWrap(''
			. 'The domain editor works with space delimited input. '
			. 'First domain on that line is considered the primary domain. '
			. 'Other domains on that same line point to the same web root and SSL cert. '
			. 'In the SSL cert this would be your primary domain and alt domains.'
		), 2);

		$Server->Domains = $this->QueryDomainLineList(
			$Server->Domains
		);

		return $Server;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Common\Meta\Date('2023-11-11')]
	public function
	WriteProjectConfig(Atlantis\Struct\ProjectJSON $Project):
	void {

		$this->PrintLn($this->FormatHeaderPoint(
			"Updating {$Project->Filename}...",
			Console\Theme::Accent
		), 2);

		if(!$Project->Write())
		throw new Common\Error\FileWriteError($Project->Filename);

		return;
	}

	#[Common\Meta\Date('2023-11-10')]
	public function
	WriteWebServerConfig(Atlantis\Struct\ProjectJSON $Project):
	void {

		$Filename = NULL;
		$Contents = NULL;

		if($Project->Web->Type === 'apachectl') {
			$Filename = 'apache24.conf';
			$Contents = $Project->Web->ToApache24($this->App);
		}

		////////

		$Filename = $this->App->FromConfEnv($Filename);

		$this->PrintLn($this->FormatHeaderPoint(
			"Updating {$Filename}...",
			Console\Theme::Accent
		), 2);

		////////

		if(file_exists($Filename) && !is_writable($Filename))
		throw new Common\Error\FileUnwritable($Filename);

		elseif(!is_writable(dirname($Filename)))
		throw new Common\Error\DirUnwritable($Filename);

		////////

		$Bytes = file_put_contents($Filename, $Contents);

		if($Bytes === FALSE)
		throw new Common\Error\FileWriteError($Filename);

		return;
	}

}

exit(DevTool::Realboot([]));
