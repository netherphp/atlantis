<?php

use Nether\Atlantis;
use Nether\Common;
use Nether\Console;
use Nether\User;

use Nether\Atlantis\Struct\AtlantisProjectJSON;
use Nether\Atlantis\Struct\AtlantisProjectSSL;

(function(){
	require(sprintf('%s/autoload.php', dirname(__DIR__, 3)));
	return;
})();

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

#[Console\Meta\Application('Atlantis SSL Tool', '5.0.0-dev')]
class CertTool
extends Console\Client {

	protected Atlantis\Engine
	$App;

	////////////////////////////////////////////////////////////////
	// OVERRIDES Console\Client ////////////////////////////////////

	protected function
	OnReady():
	void {

		$Env = $this->GetOption('env');

		if(is_string($Env) && strlen($Env))
		$_ENV['ATLANTIS.ENV'] = $Env;

		$this->App = new Atlantis\Engine(
			Atlantis\Util::GetBinProjectDirectory(__FILE__)
		);

		return;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Common\Meta\Date('2023-10-12')]
	#[Console\Meta\Command('setup')]
	#[Console\Meta\Info('Run the setup wizard to configure the SSL for this Environment.')]
	#[Console\Meta\Toggle('--appconf', 'Write to the root atlantis.json file instead of the environment atlantis.json.')]
	#[Console\Meta\Toggle('--verbose', 'Shows the resulting configuration values in the output as well.')]
	#[Console\Meta\Error(1, 'No atlantis.json file found.')]
	public function
	HandleSetupCert():
	int {

		$OptUseAppConf = $this->GetOption('appconf') ?: FALSE;
		$OptVerbose = $this->GetOption('verbose') ?: FALSE;

		////////

		$Projs = AtlantisProjectJSON::FromAppStacked($this->App);
		$Proj = $Projs['Env'];

		if($OptUseAppConf)
		$Proj = $Projs['App'];

		if($Proj === NULL)
		$this->Quit(1);

		////////

		$Proj->SSL = $this->QueryUserForCertInfo($Proj);

		$this->PrintLn($this->FormatHeading('Project SSL Config'));
		$this->PrintLn($this->Format($Proj->GetFilename(), static::FmtMuted), 2);

		if($OptVerbose)
		$this->PrintLn($this->FormatBulletList($Proj->SSL->ToArrayFlat()));

		if($Proj->SSL->Service === 'AcmePHP') (function() use($Proj, $OptVerbose) {
			$AcmeConf = $this->App->GetEnvConfigRoot('acmephp.yml');
			$AcmeYaml = $Proj->SSL->ToAcmeYaml($this->App);

			$this->PrintLn($this->FormatHeading('AcmePHP YAML'));
			$this->PrintLn($this->Format($AcmeConf, static::FmtMuted), 2);

			if($OptVerbose)
			$this->PrintLn($this->Format($AcmeYaml, static::FmtDefault), 2);

			file_put_contents($AcmeConf, $AcmeYaml);
			return;
		})();

		$Proj->Write();

		return 0;
	}

	#[Common\Meta\Date('2023-10-12')]
	protected function
	QueryUserForCertInfo(AtlantisProjectJSON $Project):
	Atlantis\Struct\AtlantisProjectSSL {

		$SSL = new AtlantisProjectSSL;

		$DefaultSSL = fn(?AtlantisProjectSSL $J, string $P)=> match(TRUE) {
			(is_object($J) && isset($J->{$P}))
			=> match(TRUE) {
				($J->{$P} instanceof Common\Datastore)
				=> $J->{$P}->Join(', '),

				default
				=> $J->{$P}
			},

			default
			=> NULL
		};

		////////

		$SSL->Domain = $this->PromptForValue(
			'Primary Domain',
			'domain.tld', TRUE,
			Default: $DefaultSSL($Project->SSL, 'Domain')
		);

		////////

		($SSL->AltDomains)
		->SetData($this->PromptForValue(
			'Alt Domains',
			'domain.tld csv, "none" to unset', FALSE,
			Filter: function(?string $In) {
				if(!$In)
				return [ ];

				if(!str_contains($In, ','))
				return [ $In ];

				return explode(',', $In);
			},
			Default: $DefaultSSL($Project->SSL, 'AltDomains')
		))
		->Remap(fn(string $D)=> trim($D))
		->Filter(fn(string $D)=> !!$D)
		->Filter(fn(string $D)=> $D !== 'none' && $D !== 'null');

		////////

		$SSL->OrgName = $this->PromptForValue(
			'Company/Org Name',
			'string', TRUE,
			Default: $DefaultSSL($Project->SSL, 'OrgName')
		);

		$SSL->Country = $this->PromptForValue(
			'Company/Org Country',
			'string, UNLOCODE preferred', TRUE,
			Default: $DefaultSSL($Project->SSL, 'Country')
		);

		$SSL->City = $this->PromptForValue(
			'Company/Org City',
			'string, UNLOCODE preferred', TRUE,
			Default: $DefaultSSL($Project->SSL, 'City')
		);

		////////

		$SSL->Email = $this->PromptForValue(
			'Tech Contact Email',
			'string', TRUE,
			Common\Filters\Text::Email(...),
			Default: $DefaultSSL($Project->SSL, 'Email')
		);

		////////

		return $SSL;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Console\Meta\Command('lookup')]
	#[Console\Meta\Info('Check the status of an SSL cert for any domain on the internet.')]
	#[Console\Meta\Arg('domain')]
	#[Console\Meta\Error(1, 'no domain specified')]
	#[Console\Meta\Error(2, 'cert lookup failure: %s')]
	#[Console\Meta\Error(3, 'cert unexpected format: %s')]
	public function
	HandleLookupCert():
	int {

		$Domain = $this->GetInput(1);
		$Via = 'openssl';
		$Format = 'cli';
		$Result = NULL;
		$Key = NULL;
		$Val = NULL;

		////////

		if(!$Domain)
		$this->Quit(1);

		////////

		if($this->GetOption('json')) {
			if($this->GetOption('pretty'))
			$Format = 'json-pretty';
			else
			$Format = 'json';
		}


		if($this->GetOption('openssl'))
		$Via = 'openssl';

		if($this->GetOption('curl'))
		$Via = 'curl';

		////////

		try {
			$Result = match($Via) {
				'curl'
				=> Atlantis\Util\CertInfo::FetchViaCurl($Domain),

				default
				=> Atlantis\Util\CertInfo::FetchViaOpenSSL($Domain)
			};
		}

		catch(Throwable $Error) { }

		$Output = [
			'Domain' => $Domain,
			'Status' => (
				$Result
				? $Result->GetStatusWord()
				: NULL
			),
			'Code' => (
				$Result
				? $Result->GetStatusCode()
				: NULL
			),
			'Date' => (
				$Result
				? (string)($Result->DateStart)
				: NULL
			),
			'ExpireDate' => (
				$Result
				? (string)($Result->DateExpire)
				: NULL
			),
			'ExpireTimeframe' => (
				$Result
				? (string)($Result->GetTimeframe())
				: NULL
			),
			'Source' => (
				$Result
				? (string)($Result->Source)
				: NULL
			)
		];

		////////

		if($Format === 'json') {
			$this->PrintLn(json_encode($Output));
			return 0;
		}

		if($Format === 'json-pretty') {
			$this->PrintLn(json_encode($Output, JSON_PRETTY_PRINT));
			return 0;
		}

		////////

		foreach($Output as $Key => $Val) {

			if($Output['Code'] !== NULL)
			if($Key === 'Domain' || $Key === 'Status') {
				$this->PrintLn(sprintf(
					'%s %s',
					$this->FormatPrimary("{$Key}:"),
					match($Output['Code']) {
						0=> $this->Formatter->BoldRed(strtoupper($Val)),
						1=> $this->Formatter->BoldGreen(strtoupper($Val)),
						2=> $this->Formatter->BoldYellow(strtoupper($Val)),
						3=> $this->Formatter->BoldMagenta(strtoupper($Val)),
						default=> strtoupper($Val)
					}
				));

				continue;
			}

			$this->PrintLn(sprintf(
				'%s %s',
				$this->FormatPrimary("{$Key}:"),
				$Val !== NULL
				? $Val
				: $this->FormatErrorPrimary('ERROR')
			));
		}

		return 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Console\Meta\Command('renew')]
	#[Console\Meta\Info('Renew the certificate for the currently configured Environment.')]
	#[Console\Meta\Value('--env', 'Run for specified Environment instead of current.')]
	#[Console\Meta\Error(1, 'EXCEPTION: %s')]
	#[Console\Meta\Error(2, 'Renewal Failure')]
	public function
	HandleRenewCert():
	int {

		$EnvConf = $this->App->GetEnvConfigRoot('atlantis.json');
		$EnvProj = NULL;

		try { $EnvProj = AtlantisProjectJSON::FromFile($EnvConf); }
		catch(Exception $E) { }

		////////

		$UseSudo = TRUE;
		$UseRehash = TRUE;

		if($UseSudo && $this->Sudo())
		return 0;

		////////

		try {
			$Result = match($EnvProj->SSL->Service) {
				default
				=> $this->HandleRenewCert_ViaAcmePHP($EnvProj)
			};
		}

		catch(Exception $Err) { $this->Quit(1, $Err); }

		////////

		if(!$Result)
		$this->Quit(2);

		////////

		if($UseRehash)
		$this->RehashWebserver($UseSudo);

		return 0;
	}

	protected function
	HandleRenewCert_ViaAcmePHP(AtlantisProjectJSON $Project):
	bool {

		$Filename = $this->GetOption('filename') ?? 'acmephp.yml';
		$AcmeConf = $this->App->GetEnvConfigRoot($Filename);
		$AcmeBin = '/opt/ssl/acmephp.phar';

		$Command = NULL;
		$Result = NULL;

		////////

		if(!file_exists($AcmeConf))
		throw new Common\Error\FileNotFound($AcmeConf);

		////////

		$Command = sprintf('%s run %s 2>&1', $AcmeBin, $AcmeConf);
		$Result = $this->ExecuteCommandLine($Command);

		if($Result->Error) {
			$this->PrintLn($this->FormatPrimary('Command Output:'));
			$Result->Print('> ');
			return FALSE;
		}

		return TRUE;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	#[Console\Meta\Command('cron')]
	#[Console\Meta\Info('Shows the line to be added to crontab to auto-renew SSL.')]
	public function
	HandleGenerateCron():
	int {

		$Time = $this->GetOption('time') ?? '0420';
		$ShouldAdd = $this->GetOption('add') ?? FALSE;
		$ShouldRemove = $this->GetOption('remove') ?? FALSE;
		$UseLocalTime = $this->GetOption('local') ?? FALSE;

		$Crontab = Common\Struct\CrontabFile::FetchViaSystemUser();
		$Command = $this->GenerateCommmandForAtlantisSSL();
		$HasAtlantisSSL = $this->CheckForAtlantisSSL($Crontab);
		$Count = NULL;

		$Row = new Common\Struct\CrontabEntry;
		$Row->SetCommand($Command);
		$Row->SetupDailyTime($Time, $UseLocalTime);

		$this
		->PrintLn(sprintf(
			'%s %s',
			$this->FormatPrimary('Crontab:'),
			$Row->GetAsCrontab()
		))
		->PrintLn(sprintf(
			'%s %s (in %s)',
			$this->FormatSecondary('Runs At:'),
			$Row->GetTimerAsWords(),
			$Row->GetTimerAsTimeframe()
		));

		////////

		if($ShouldAdd && $HasAtlantisSSL) {
			$this
			->PrintLn(sprintf(
				'%s %s',
				$this->FormatSecondary('Result:'),
				'Entry for SSL renewals already found in Crontab.'
			))
			->PrintLn();

			return 0;
		}

		if($ShouldAdd && !$HasAtlantisSSL) {
			$Crontab->Push($Row);
			$Crontab->Write();

			////////

			$Crontab = Common\Struct\CrontabFile::FetchViaSystemUser();
			$HasAtlantisSSL = $this->CheckForAtlantisSSL($Crontab);

			if(!$HasAtlantisSSL) {
				$this
				->PrintLn(sprintf(
					'%s %s',
					$this->FormatErrorPrimary('ERROR:'),
					'The entry to add via Crontab did not stick.'
				))
				->PrintLn();

				return 1;
			}

			$this
			->PrintLn(sprintf(
				'%s %s',
				$this->FormatSecondary('Result:'),
				'The entry has been added to Crontab.'
			))
			->PrintLn();
		}

		if($ShouldRemove) {
			$Count = $Crontab->Count();

			$Crontab->Filter(function(?Common\Struct\CrontabEntry $Item) {
				if(!$Item)
				return TRUE;

				if(str_contains($Item->Command, 'atlantis acmephp-run'))
				return FALSE;

				return TRUE;
			});

			$Crontab->Write();

			if($Count === $Crontab->Count()) {
				$this
				->PrintLn(sprintf(
					'%s %s',
					$this->FormatErrorPrimary('ERROR:'),
					'Did not find any entries to remove.'
				))
				->PrintLn();

				return 1;
			}

		}

		////////

		return 0;
	}

	public function
	GenerateCommmandForAtlantisSSL(int $Version=1):
	string {

		return match($Version) {
			default => sprintf(
				'env php %s renew',
				Common\Filesystem\Util::Pathify(
					$this->App->GetProjectRoot(),
					'vendor', 'bin', 'ssl.atl'
				)
			)
		};
	}

	public function
	CheckForAtlantisSSL(Common\Struct\CrontabFile $File):
	bool {

		$Command = $this->GenerateCommmandForAtlantisSSL();

		$Found = (
			$File
			->Distill(Common\Struct\CrontabFile::FilterCrontabLine(...))
			->Filter(
				fn(Common\Struct\CrontabEntry $Row)
				=> str_starts_with($Row->Command, $Command)
			)
			->Count()
		);

		return $Found !== 0;
	}

	////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////

	protected function
	RehashWebserver(bool $UseSudo=FALSE):
	void {

		$Command = sprintf(
			'%s webserver-rehash %s',
			Common\Filesystem\Util::Pathify(
				$this->App->GetProjectRoot(),
				'vendor', 'bin', 'atlantis'
			),
			($UseSudo ? '--sudo' : '')
		);

		$this->ExecuteCommandLine($Command);

		return;
	}

}

exit((new CertTool)->Run());
